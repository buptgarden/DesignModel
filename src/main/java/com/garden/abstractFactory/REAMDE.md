# 使用场景
* 如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 
在这种情况下， 你可以使用抽象工厂。抽象工厂为你提供一个接口，可用于创建每个系列的产品的对象。只要代码通过该接口创建对象，那么你就不会生成与应用程序以生成的不一致的产品。
* 如果你有基于一组抽象方法的类，且其主要功能因此变得不明确，那么这种情况下可以考虑使用抽象工厂模式。良好的设计模式中，每个类负责一件事。如果一个类与多种类型产品交互，可以考虑将工厂方法抽取到独立的工厂类或者完备的抽象工厂类中。
# 实现方式
* 以不同的产品类型与产品变体为纬度绘制矩阵。
* 为所有产品声明抽象接口。然后让所有具体产品类实现这些接口。
* 声明抽象工厂接口，并且在接口中为所有抽象产品提供一组构建方法。
* 为每种产品变体实现一个工厂类。
* 在应用程序初始化阶段，根据配置或者环境，对特定的工厂类初始化，然后将工厂类传递给所有需要创建产品的类。
# 优缺点
* 可以确保同一工厂生成的产品互相匹配
* 可以避免客户端和具体产品的耦合。
* 单一职责原则。将产品生成代码抽取到同一位置。
* 开闭原则，向应用程序中引入新的产品变体时，无需修改客户端。
* 缺点，代码变得更复杂。
# 和其他模式关系
* 初期使用工厂方法模式，后向抽象工厂模式，原型模式或生成器模式
* 生成器的重点是关注如何生成负责对象。抽象工厂专门用于生产一系列相关的对象。抽象工厂会马上返回产品，生成器则允许在获取产品前执行额外构造步骤。
* 抽象工厂模式基于一组工厂方法，但你也可以使用原型模式来生成这些类的方法。
* 当只需要对客户端隐藏子系统创建对象方式是，可以使用抽象工厂类代替外观模式。
* 可以将抽象工厂和桥接模式搭配使用。有桥接定义抽象与指定的实现合作。这种情况下，抽象工厂可以对这些关系进行封装，并且对客户端代码隐藏复杂性。
* 抽象工厂，生成器和原型都可以使用单例模式来实现。