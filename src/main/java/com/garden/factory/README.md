# 适用场景
* 在编写代码过程中，无法预知对象确切类别及依赖关系时，可用工厂方法，例如：工厂方法将创建产品的代码与实际使用的代码分离，从而能在不影响其他代码
情况下扩展创建部分代码。在添加一种新产品时，你只需要开发新的创建这子类，然后重写其创建方法即可。
* 如果，你希望用户能扩展你的软件库或框架内部组件，可适用工厂方法。例如，继承可能是扩展软件库或者框架默认行为的最简单方法。但是在适用子类替代标准
组件时，框架如何识别该子类？方法是将各个框架的构建组件代码集中到单个工厂方法中，并且允许任何人重写该方法。
* 如果需要复用现有对象（如数据库连接，文件系统和网络资源），你会经常工厂方法。
# 实现方式
1. 让所有的产品都遵循同一接口，该接口的方法必须对所有产品都有意义。
2. 在创建类中加一个抽象的工厂方法。该方法返回类型必须遵循通用的产品接口。
3. 在创建者代码中找到所有对于产品构造函数的引用。替换为工厂方法。然后迁移创建逻辑到工厂方法。
4. 为每个产品编写一个创建者子类，在子类中重写工厂方法。
5. 如果产品类型太多，那么为每个产品创建子类并无必要，可用在子类中复用基类中的控制参数。
# 优缺点
1. 解耦合，创建者和具体产品分离。
2. 单一职责原则，将产品创建代码放置到单一位置，使得代码更加易维护。
3. 开闭原则。无需更改现有客户端代码，即可引入新产品。
4. 引入子类，代码更加复杂
# 与其他模式的关系
* 许多设计的初期都是工厂方法模式，随后演化为使用抽象工厂、原型模式或生成器模式
* 抽象工厂模式通常基于一组工厂方法，但也可以使用原型模式。
* 可以使用工厂方法和迭代器模式来让子类集合返回不同类型迭代器，并使得迭代器与集合相匹配。
* 原型不基于继承，没有继承的缺点。另一方面，原型需要对被复制对西那个进行复杂初始化。工厂方法不需要。
* 工厂方法是模版方法的一种特殊形式。同时，工厂方法可以作为大型模版方法中的一个步骤。
